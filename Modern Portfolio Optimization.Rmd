---
title: "Modern Portfolio Optimization"
output:
  pdf_document: default
  html_document: default
date: "2022-11-22"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

###Libraries loading
# Core
library(tidyverse)
## Finance analytics
library(tidyquant)
# Optimization Solving
library(quadprog)
# Visualization 
library(plotly)
```

```{r}
###Data Input
stock <- c("AAPL", "META", "OXY", "SE", "TSLA")
data <- tq_get(stock, get = "stock.prices", complete_cases = TRUE, from = "2017-01-01", to = TODAY())
returns_data <- data %>%
    select(symbol, date, adjusted) %>%
    group_by(symbol)%>%
    tq_transmute(adjusted, 
                 mutate_fun = periodReturn, 
                 period = "yearly", 
                 col_rename = "Yearly Return")

### Stats Calculations
# Expected Return and Standard Deviation
stats <- returns_data %>%
  summarise(
    Yearly_Expected_Return = mean(`Yearly Return`),
    Standard_Deviation = sd(`Yearly Return`)
  )
#Covariance
returns_matrix <- tidyr::spread(returns_data, 
                                key = "symbol", 
                                value = "Yearly Return")
covariance_matrix <- cov(returns_matrix[,-1])

### Optimization
# Objective matrix
Dmat <- 2*covariance_matrix
#Objective vector
dvec <- c(0,0,0,0,0)
# Constraint Matrix
Amat <- t(matrix(c(1, as.numeric(stats[stats$symbol == "AAPL", "Yearly_Expected_Return"]),1,0,0,0,0,
                   1,as.numeric(stats[stats$symbol == "META", "Yearly_Expected_Return"]),0,1,0,0,0,
                   1,as.numeric(stats[stats$symbol == "OXY", "Yearly_Expected_Return"]),0,0,1,0,0,
                   1,as.numeric(stats[stats$symbol == "SE", "Yearly_Expected_Return"]),0,0,0,1,0,
                   1,as.numeric(stats[stats$symbol == "TSLA", "Yearly_Expected_Return"]),0,0,0,0,1),7,5))
# Require Return (Set at 0.5)
goal <- 0.5
# Right hand side
bvec <- c(1,goal,0,0,0,0,0)
#Quadratic Programming Solving
qp <- solve.QP(Dmat, 
               dvec, 
               Amat, 
               bvec, 
               meq = 1)


### Data Output
# Printing
returns_data
stats
portfolio_weights <- rbind(stock, round(qp$solution, 4))
portfolio_weights
portfolio_variance <- qp$value
portfolio_variance
```
```{r}
### For checking result only
calc_portfolio_variance <- function(weights) {
    t(weights) %*% (covariance_matrix %*% weights) %>% as.vector()
}
calc_portfolio_variance(qp$solution) #Should be equal to portfolio_covariance
calc_portfolio_return <- function(weights) {
    stats_mean <- stats$Yearly_Expected_Return
    sum(stats_mean * weights)
}
calc_portfolio_return(qp$solution) #Should be equal to goal
```

```{r}
###Visualization
port_return <- c()
port_variance <-c()
min_return_in_percent <- ceiling(min(stats$Yearly_Expected_Return)*100)
max_return_in_percent <- floor(max(stats$Yearly_Expected_Return)*100)
for (n in (min_return_in_percent:max_return_in_percent)){
  expected_portfolio_return <- n/100
  new_bvec <- c(1,expected_portfolio_return,0,0,0,0,0)
  qp <- solve.QP(Dmat, dvec, Amat, new_bvec, meq = 1)
  port_return <- c(port_return, expected_portfolio_return)
  port_variance <- c(port_variance, qp$value)
}
efficient_frontier <- plot_ly(x = port_variance, 
                              y = port_return,
                              type = 'scatter',
                              mode = 'lines+markers')%>%
  layout(title = "Efficient Frontier", xaxis = list(title = "Portfolio Variance (Risk)"), yaxis = list(title = "Portfolio Return"))
efficient_frontier
```

 
